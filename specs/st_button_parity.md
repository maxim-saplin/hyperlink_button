# st.button parity specification

This document records the required API and behavioral parity for `st.button` based on the Streamlit reference docs under `st_docs/` and related conceptual pages.

Files consulted (citations):
- `st_docs/develop/api-reference/widgets/button.md`
- `st_docs/develop/concepts/app-design/button-behavior-and-examples.md`
- `st_docs/develop/concepts/architecture/session-state.md`
- any testing docs that mention widgets (search under `st_docs/develop`)

Purpose
- Define the function signature, parameter meanings, return semantics, callback semantics, disabled behavior, and key/id stability considerations so an implementation can match behaviorally.

1. Function signature (surface API)

Documented in `st_docs/develop/api-reference/widgets/button.md` (autogenerated), and verified for the current Docker image Streamlit version (1.54.0) via `inspect.signature(st.button)`.

Current Streamlit 1.54.0 signature:
- `st.button(label, key=None, help=None, on_click=None, args=None, kwargs=None, *, type='secondary', icon=None, icon_position='left', disabled=False, use_container_width=None, width='content', shortcut=None) -> bool`

Notes:
  - `label` (required positional) — visible text inside the button.
  - `key` — stable identifier for widget across reruns/session; used for session-state and to disambiguate multiple widgets with same label.
  - `help` — optional hover tooltip text.
  - `on_click` — optional callable to run when the button is activated; callback should run in the same rerun that processes the click.
  - `args` / `kwargs` — optional positional/keyword arguments passed to `on_click` when invoked.
  - `type` — controls styling variant (primary/secondary/tertiary).
  - `icon` / `icon_position` — optional icon and position.
  - `disabled` — boolean; when true the widget is rendered in a disabled state and is non-interactive.
  - `use_container_width` / `width` — sizing behavior.
  - `shortcut` — optional keyboard shortcut.

2. Return semantics
- When `on_click` is not provided: `st.button` returns a boolean indicating whether the button was clicked during the current script run. Only a single `True` should be returned on the run that processes the click; subsequent reruns return `False` unless clicked again.
- When `on_click` is provided: the return boolean behavior is the same; `on_click` is invoked as a side-effect during the handling of the click. Implementations may still return the boolean so callers can check both return value and provided callback.

3. Callback semantics
- Callbacks are executed synchronously as part of the rerun triggered by the click.
- `on_click` is called once per activation with the provided `args` and `kwargs`.
- Exceptions raised by `on_click` should propagate to the app-level error handling (i.e., the rerun surfaces the traceback). Implementations may catch exceptions to render a user-facing error but should not silently swallow them.

4. Disabled behavior
- When `disabled=True` the widget should render visually disabled and not accept clicks. The `on_click` callback must not be invoked and the return value must always be `False` on reruns triggered by other events.

5. Key / ID stability and session integration
- `key` is the stable identifier used to track widget state across reruns and to index session-state entries.
- If `key` is omitted, implementations infer an ID from the widget position and label; this can change if code structure changes (reordering, conditionals). To ensure stable behavior, callers should supply explicit `key` when they rely on persistence.
- Button widgets typically have no stored value in session-state other than transient activation; however when `on_click` is used it may set values in session-state. The spec requires predictable interaction with session-state per: `st_docs/develop/concepts/architecture/session-state.md`.

6. Edge cases and behavior details
- Multiple buttons with same label: distinguish by `key`; if no key provided, implement position-based disambiguation. Only the clicked button returns `True`.
- Rapid repeated clicks: each physical click should queue a rerun; implementations inside Streamlit batch clicks into discrete reruns — the parity implementation must ensure exactly one activation per actual user click.
- Disabled then enabled across reruns: enabling a widget should not retroactively invoke callbacks for past clicks.
- Long-running callbacks: if `on_click` blocks, the UI should indicate progress per app runtime conventions; the call is synchronous to the rerun.

7. Testing and verification (Docker-only tests to run later)
- Verify basic click: run an app with `st.button('Click me')` and assert the script returns `True` for the run after a programmatic click simulated by the headless browser.
- Verify `on_click` invocation: use `on_click` to increment a session-state counter and assert counter increments once per click.
- Verify `disabled`: render with `disabled=True`, attempt click, assert no callback and return is `False`.
- Verify key stability: render two buttons with same label but different keys and assert clicks map to the correct key.

8. Unknowns not documented (items that require confirmation in `st_docs` or runtime)
- Whether any signature details vary by Streamlit version. Proposed verification: run `uv run python -c "import streamlit as st; import inspect; print(st.__version__); print(inspect.signature(st.button))"` inside Docker for the pinned app image.
- Whether `st.button` stores any persistent boolean in session-state by default: propose a test that inspects `st.session_state` keys before and after a click to confirm presence/absence.
- Concurrency model for clicks arriving during an ongoing `on_click`: confirm if Streamlit queues or drops extra activations. Proposed test: use a callback that sleeps for N seconds and trigger multiple clicks rapidly from a headless browser, then check how many times the callback ran.
- Tooltip behavior: whether `help` maps to `title` attribute or a custom tooltip component. Proposed test: render `st.button('b', help='h')` and inspect the generated DOM in a headless browser.

9. Minimal example snippets (for tests/docs)
```python
import streamlit as st

if 'count' not in st.session_state:
    st.session_state.count = 0

def cb():
    st.session_state.count += 1

if st.button('Click', key='btn', on_click=cb):
    st.write('Button return True this run')

st.write('count =', st.session_state.count)
```

10. Handoff packet (for subagents)
- Changed paths:
  - `specs/st_button_parity.md` (new file)
- Why:
  - Provide a precise parity spec for `st.button` so implementers can match API surface and runtime semantics to Streamlit.
- Verification performed:
  - Documentation-only change; no runtime verification performed here. Proposed Docker-only commands are listed in section 7 for later execution.
- Known limitations and follow-ups:
  1. Several API details were inferred where `st_docs` uses autogenerated `<Autofunction />` pages; these are listed under "Unknowns not documented" and include proposed Docker-only verification commands.
  2. No changes were made to runtime code or tests; implementers should run the test list in section 7 inside the project's Docker environment.

End of spec.
